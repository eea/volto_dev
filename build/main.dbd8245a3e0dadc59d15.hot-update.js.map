{"version":3,"file":"main.dbd8245a3e0dadc59d15.hot-update.js","sources":["webpack:///./volto-mosaic/src/components/manage/BlockEditor.jsx","webpack:///./volto-mosaic/src/components/manage/Form.jsx"],"sourcesContent":["import React, { Component } from 'react';\n\nimport { doesNodeContainClick } from 'semantic-ui-react/dist/commonjs/lib';\nimport { blocks } from '~/config';\nimport { Tab, Button, Modal, Grid } from 'semantic-ui-react';\nimport { Icon as VoltoIcon, BlockChooser } from '@plone/volto/components';\n\nimport BlockMetadataEditor from './BlockMetadataEditor';\n\nimport penIcon from '@plone/volto/icons/pen.svg';\nimport clearIcon from '@plone/volto/icons/clear.svg';\n\n// import PropTypes from 'prop-types';\n// import blockDataEditor from './blockDataEditor';\n\nclass ModalEditor extends Component {\n  constructor(props) {\n    super(props);\n\n    const block = JSON.parse(\n      JSON.stringify(props.formData['blocks'][props.blockid]),\n    );\n\n    this.state = {\n      // blocks: props.blocks,\n      blockid: props.blockid,\n      formData: props.formData,\n      blockData: block,\n      showBlockChooser: false,\n      activeTabPage: 0,\n    };\n\n    this.blockRef = React.createRef();\n\n    this.renderEditBlock = this.renderEditBlock.bind(this);\n\n    // this is ugly, should reduce number of similar methods\n    this.onChangeBlock = this.onChangeBlock.bind(this);\n    this.onMutateBlock = this.onMutateBlock.bind(this);\n    this.handleMetadataChange = this.handleMetadataChange.bind(this);\n    this.updateblockData = this.updateblockData.bind(this);\n    this.handleTabChange = this.handleTabChange.bind(this);\n\n    this.panes = [];\n  }\n\n  handleClickOutside = e => {\n    if (this.ref && doesNodeContainClick(this.ref, e)) return;\n    this.setState(() => ({\n      showBlockChooser: false,\n    }));\n  };\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.handleClickOutside, false);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.handleClickOutside, false);\n  }\n\n  renderEditBlock() {\n    // const { formData } = this.state; // destructuring\n    // const blocksFieldname = getBlocksFieldname(formData);\n    // const blocksDict = formData[blocksFieldname];\n\n    let Block = null;\n    let type = this.state.blockData['@type'].toLowerCase();\n    Block = blocks.blocksConfig[type].edit;\n\n    let nop = () => {};\n\n    return (\n      <Block\n        id={this.state.blockid}\n        block={this.state.blockid}\n        data={this.state.blockData}\n        properties={this.state.formData}\n        onAddBlock={nop}\n        onChangeBlock={this.onChangeBlock}\n        onMutateBlock={nop}\n        onChangeField={nop}\n        onDeleteBlock={nop}\n        onSelectBlock={nop}\n        handleKeyDown={nop}\n        pathname={this.props.pathname}\n        onMoveBlock={nop}\n        onFocusPreviousBlock={nop}\n        onFocusNextBlock={nop}\n        selected={true}\n        index={0}\n        ref={this.blockRef}\n      />\n    );\n  }\n\n  onChangeBlock(id, value) {\n    // handles editing inside the actual block editor (ex: TinyMCE)\n    this.setState({\n      blockData: { ...value },\n    });\n  }\n\n  onMutateBlock(block, choice) {\n    // handles changing the block type. Needed by the <Block> component?\n    this.setState({\n      blockData: {\n        ...this.state.blockData,\n        ...choice,\n      },\n      showBlockChooser: false,\n      activeTabPage: 0,\n    });\n  }\n\n  handleMetadataChange(values) {\n    // handles changes coming from the metadata editor\n\n    let blockData = this.state.blockData;\n    this.setState(\n      {\n        blockData: {\n          ...blockData,\n          ...values,\n        },\n      },\n      () => {\n        // console.log('State after handleMetadataChange', this.state);\n      },\n    );\n  }\n\n  updateblockData(name, data) {\n    let blockData = this.state.blockData;\n    // TODO: check if this doesn't introduce extra render of block editor\n\n    this.setState({\n      blockData: {\n        ...blockData,\n        [name]: data,\n      },\n    });\n  }\n\n  handleTabChange(e, { activeIndex }) {\n    this.setState({\n      activeTabPage: activeIndex,\n    });\n  }\n\n  render() {\n    return (\n      <Modal open={true} size=\"fullscreen\">\n        <Modal.Content scrolling>\n          <Tab\n            onTabChange={this.handleTabChange}\n            activeIndex={this.state.activeTabPage}\n            menu={{\n              secondary: true,\n              pointing: true,\n              attached: true,\n              tabular: true,\n            }}\n            panes={[\n              {\n                menuItem: 'Data',\n                render: () => <Tab.Pane>{this.renderEditBlock()}</Tab.Pane>,\n              },\n              {\n                menuItem: 'Metadata',\n                render: () => (\n                  <Tab.Pane>\n                    <BlockMetadataEditor\n                      onDataChange={this.handleMetadataChange}\n                      blockData={this.state.blockData}\n                    />\n                  </Tab.Pane>\n                ),\n              },\n            ]}\n          />\n        </Modal.Content>\n        <Modal.Actions>\n          <Grid columns={2}>\n            <Grid.Column style={{ textAlign: 'left' }}>\n              <Button.Group floated=\"left\">\n                <Button\n                  onClick={() => this.setState({ showBlockChooser: true })}\n                >\n                  {this.state.blockData['@type']\n                    ? blocks.blocksConfig[this.state.blockData['@type']].title\n                    : 'Set type'}\n                </Button>\n\n                <div ref={node => (this.ref = node)}>\n                  {this.state.showBlockChooser && (\n                    <BlockChooser\n                      onMutateBlock={this.onMutateBlock}\n                      currentBlock={this.state.blockData}\n                    />\n                  )}\n                </div>\n              </Button.Group>\n            </Grid.Column>\n            <Grid.Column>\n              <Button.Group floated=\"right\">\n                <Button\n                  basic\n                  circular\n                  primary\n                  onClick={() => this.props.onClose(this.state.blockData)}\n                >\n                  <VoltoIcon name={penIcon} className=\"circled\" />\n                </Button>\n                <Button\n                  basic\n                  circular\n                  secondary\n                  size=\"big\"\n                  onClick={() => this.props.onClose()}\n                >\n                  <VoltoIcon name={clearIcon} className=\"circled\" />\n                </Button>\n              </Button.Group>\n            </Grid.Column>\n          </Grid>\n        </Modal.Actions>\n      </Modal>\n    );\n  }\n}\n\nexport default ModalEditor;\n","// import ReactDOM from 'react-dom';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { keys, map, mapValues, omit, uniq, without } from 'lodash';\nimport { Button, Form as UiForm, Segment } from 'semantic-ui-react';\nimport { defineMessages, injectIntl } from 'react-intl';\nimport { v4 as uuid } from 'uuid';\nimport { Portal } from 'react-portal';\n\nimport { Field, Icon } from '@plone/volto/components'; // EditBlock\nimport {\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\n\nimport _ from 'lodash';\n\nimport RGL from 'react-grid-layout';\n\nimport 'react-grid-layout/css/styles.css';\nimport 'react-resizable/css/styles.css';\n\nimport { SizeMe } from 'react-sizeme';\n\nimport '../css/edit.css';\nimport '../css/view.css';\n\nimport { rowHeight, breakpoints, screenSizes } from '../../config';\n\nimport BlockEditor from './BlockEditor';\nimport LayoutToolbar from './LayoutToolbar';\nimport { BlockViewWrapper } from './../theme/View';\n\nimport deleteIcon from '@plone/volto/icons/delete.svg';\nimport editIcon from '@plone/volto/icons/editing.svg';\n\nimport { blocks } from '~/config';\n// import move from 'lodash-move';\n// import aheadSVG from '@plone/volto/icons/ahead.svg';\n// import clearSVG from '@plone/volto/icons/clear.svg';\nconst ReactGridLayout = RGL;\n\nconst screens = Object.keys(screenSizes).map(k => {\n  return { key: k, text: screenSizes[k], value: k };\n});\n\nconst messages = defineMessages({\n  addBlock: {\n    id: 'Add block...',\n    defaultMessage: 'Add block...',\n  },\n  required: {\n    id: 'Required input is missing.',\n    defaultMessage: 'Required input is missing.',\n  },\n  minLength: {\n    id: 'Minimum length is {len}.',\n    defaultMessage: 'Minimum length is {len}.',\n  },\n  uniqueItems: {\n    id: 'Items must be unique.',\n    defaultMessage: 'Items must be unique.',\n  },\n  save: {\n    id: 'Save',\n    defaultMessage: 'Save',\n  },\n  cancel: {\n    id: 'Cancel',\n    defaultMessage: 'Cancel',\n  },\n  error: {\n    id: 'Error',\n    defaultMessage: 'Error',\n  },\n  thereWereSomeErrors: {\n    id: 'There were some errors.',\n    defaultMessage: 'There were some errors.',\n  },\n});\n\n// Instead of Object.fromEntries\nfunction fromEntries(iterable) {\n  return [...iterable].reduce((obj, [key, val]) => {\n    obj[key] = val;\n    return obj;\n  }, {});\n}\n\nfunction fallbackLayoutFromData(formData, ids) {\n  // create a default layout based on existing blocks\n\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  const order = formData[blocksLayoutFieldname].items || [];\n  const data = formData[blocksFieldname];\n\n  const fallbackLayout = [\n    {\n      // provide default block for title\n      h: 1,\n      i: ids.title,\n      w: 12,\n      x: 0,\n      y: 0,\n    },\n    {\n      // provide default block for text\n      h: 3,\n      i: ids.text,\n      w: 12,\n      x: 0,\n      y: 1,\n    },\n  ];\n\n  const validIds = order.filter(i => {\n    return Object.keys(data).indexOf(i) > -1;\n  });\n  const res = validIds.map((el, ix) => {\n    return {\n      w: 12,\n      h: ix === 0 ? 2 : 4,\n      x: 0,\n      y: ix === 0 ? 0 : 2 + (ix - 1) * 4,\n      i: el,\n    };\n  });\n\n  return res || fallbackLayout;\n}\n\nclass Form extends Component {\n  static propTypes = {\n    schema: PropTypes.shape({\n      fieldsets: PropTypes.arrayOf(\n        PropTypes.shape({\n          fields: PropTypes.arrayOf(PropTypes.string),\n          id: PropTypes.string,\n          title: PropTypes.string,\n        }),\n      ),\n      properties: PropTypes.objectOf(PropTypes.any),\n      definitions: PropTypes.objectOf(PropTypes.any),\n      required: PropTypes.arrayOf(PropTypes.string),\n    }),\n    formData: PropTypes.objectOf(PropTypes.any),\n    pathname: PropTypes.string,\n    onSubmit: PropTypes.func,\n    onCancel: PropTypes.func,\n    submitLabel: PropTypes.string,\n    resetAfterSubmit: PropTypes.bool,\n    title: PropTypes.string,\n    error: PropTypes.shape({\n      message: PropTypes.string,\n    }),\n    loading: PropTypes.bool,\n    hideActions: PropTypes.bool,\n    description: PropTypes.string,\n    visual: PropTypes.bool,\n    blocks: PropTypes.arrayOf(PropTypes.object),\n  };\n\n  static defaultProps = {\n    description: null,\n    error: null,\n    formData: null,\n    hideActions: false,\n    loading: null,\n    onCancel: null,\n    onSubmit: null,\n    pathname: '',\n    resetAfterSubmit: false,\n    schema: {},\n    submitLabel: null,\n    blocks: [],\n    title: null,\n    visual: false,\n\n    preview: false,\n    // Grid props\n    className: 'mosaic-edit-layout',\n    // cols: { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },\n    // cols: { lg: 12, md: 12, sm: 12, xs: 12, xxs: 12 },\n    cols: 12,\n    rowHeight: rowHeight,\n    margin: [0, 0],\n    layoutWidth: null, // preview responsive layout width\n    activeScreenSize: 'lg', // 'desktop' is the default screen size\n\n    payload: null, // blockData that will be saved\n  };\n\n  constructor(props) {\n    super(props);\n\n    if (__SERVER__) return;\n\n    const ids = {\n      title: uuid(),\n      text: uuid(),\n    };\n    let { formData } = props;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    if (formData === null) {\n      // get defaults from schema\n      formData = mapValues(props.schema.properties, 'default');\n    }\n    // defaults for block editor; should be moved to schema on server side\n    if (!formData[blocksLayoutFieldname]) {\n      formData[blocksLayoutFieldname] = {\n        items: [ids.title, ids.text],\n      };\n    }\n    if (!formData[blocksFieldname]) {\n      formData[blocksFieldname] = {\n        [ids.title]: {\n          '@type': 'title',\n          mosaic_block_title: 'title block',\n        },\n        [ids.text]: {\n          '@type': 'text',\n          mosaic_block_title: 'text block',\n        },\n      };\n    }\n\n    const activeScreenSize = this.props.activeScreenSize;\n    // TODO: rewrite with ? operator\n    const activeMosaicLayout =\n      (this.props.formData &&\n        this.props.formData.blocks_layout &&\n        this.props.formData.blocks_layout.mosaic_layout &&\n        this.props.formData.blocks_layout.mosaic_layout[activeScreenSize]) ||\n      fallbackLayoutFromData(formData, ids);\n\n    if (!formData[blocksLayoutFieldname].mosaic_layout) {\n      formData[blocksLayoutFieldname].mosaic_layout = {\n        lg: activeMosaicLayout,\n      };\n    }\n\n    const items = formData[blocksLayoutFieldname].items || [];\n    const refs = items.map(id => [id, React.createRef()]);\n\n    this.state = {\n      formData,\n      errors: {},\n      cols: 12,\n      availableScreens: screens,\n      layoutWidth: this.props.layoutWidth,\n      activeScreenSize,\n      activeMosaicLayout,\n      dirtyLayout: false,\n      refs: fromEntries(refs),\n      blockHeights: {},\n    };\n\n    // this.onMoveBlock = this.onMoveBlock.bind(this);\n    // this.onSelectBlock = this.onSelectBlock.bind(this);\n    // this.onDeleteBlock = this.onDeleteBlock.bind(this);\n    // this.onFocusPreviousBlock = this.onFocusPreviousBlock.bind(this);\n    // this.onFocusNextBlock = this.onFocusNextBlock.bind(this);\n    // this.handleKeyDown = this.handleKeyDown.bind(this);\n    // this.onEditBlock = this.onEditBlock.bind(this);\n    // this.renderBlockPreview = this.renderBlockPreview.bind(this);\n    // this.onDragStart = this.onDragStart.bind(this);\n    // this.onDrag = this.onDrag.bind(this);\n    // this.onResize = this.onResize.bind(this);\n    // this.onResizeStart = this.onResizeStart.bind(this);\n\n    this.onDragStop = this.onDragStop.bind(this);\n    this.onResizeStop = this.onResizeStop.bind(this);\n\n    this.onChangeField = this.onChangeField.bind(this);\n    this.onMutateBlock = this.onMutateBlock.bind(this);\n    this.onAddBlock = this.onAddBlock.bind(this);\n    this.onSubmit = this.onSubmit.bind(this);\n\n    this.createElement = this.createElement.bind(this);\n    this.onLayoutChange = this.onLayoutChange.bind(this);\n    this.handleOpen = this.handleOpen.bind(this);\n    this.handleCloseEditor = this.handleCloseEditor.bind(this);\n    this.handleLayoutToolbar = this.handleLayoutToolbar.bind(this);\n    this.onShowBlock = this.onShowBlock.bind(this);\n  }\n\n  handleOpen(blockid) {\n    this.setState({ showModal: true, currentBlock: blockid, blockHeights: {} });\n  }\n\n  handleCloseEditor(blockData) {\n    if (!blockData) {\n      this.setState({\n        showModal: false,\n        currentBlock: null,\n      });\n      return;\n    }\n\n    const blockid = this.state.currentBlock;\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [blockid]: blockData || null,\n          },\n        },\n        showModal: false,\n        preview: true,\n      },\n      () => {\n        console.log('state after handleCloseEditor', this.state);\n      },\n    );\n  }\n\n  onShowBlock(blockid, height) {\n    const formData = this.state.formData;\n\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const activeScreenSize = this.state.activeScreenSize || 'lg';\n    const blockData = formData[blocksFieldname][blockid];\n\n    const sizing = blockData.mosaic_box_sizing || 'fit-content';\n\n    let ix, lh;\n    switch (sizing) {\n      case 'fit-content':\n        this.setState(\n          (state, props) => {\n            const activeMosaicLayout = JSON.parse(\n              JSON.stringify(state.activeMosaicLayout),\n            );\n            lh = Math.ceil(height / this.props.rowHeight);\n            ix = activeMosaicLayout.indexOf(\n              activeMosaicLayout.find(el => {\n                return el.i === blockid;\n              }),\n            );\n            activeMosaicLayout[ix].h = lh;\n            return {\n              formData: {\n                ...state.formData,\n                [blocksLayoutFieldname]: {\n                  ...layoutField,\n                  mosaic_layout: {\n                    ...layoutField.mosaic_layout,\n                    [activeScreenSize]: activeMosaicLayout,\n                  },\n                },\n              },\n              activeMosaicLayout,\n            };\n          },\n          () => {\n            console.log('height of node', height, lh, blockid, this.state);\n          },\n        );\n        break;\n\n      // case 'min-height':\n      //   // TODO: get minimum block height from settings, trigger layout update\n      //   const type = formData['@type'].toLowerCase();\n      //   const minHeight = blocks.blocksConfig[type].height || 100;\n      //   height = Math.ceil(minHeight / this.props.rowHeight);\n      //   ix = activeMosaicLayout.indexOf(\n      //     activeMosaicLayout.find(el => {\n      //       return el.i === blockid;\n      //     }),\n      //   );\n      //   activeMosaicLayout[ix].h = height;\n      //   break;\n      case 'fill-space':\n        break;\n      case 'manual':\n        break;\n      default:\n        break;\n    }\n  }\n\n  onLayoutChange(newLayout) {\n    console.log('on layout change');\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    const size = this.state.activeScreenSize;\n\n    // Layout hasn't been created yet\n    if (Object.keys(mosaic_layout).indexOf(size) === -1) {\n      this.setState({\n        activeMosaicLayout: newLayout,\n      });\n      return;\n    }\n\n    this.setState(\n      (state, props) => {\n        return {\n          activeMosaicLayout: newLayout,\n          formData: {\n            ...state.formData,\n            [blocksLayoutFieldname]: {\n              ...state.formData[blocksLayoutFieldname],\n              mosaic_layout: {\n                ...state.formData[blocksLayoutFieldname].mosaic_layout,\n                [size]: newLayout,\n              },\n            },\n          },\n        };\n      },\n      () => {\n        console.log('Set state on change layout ' + size, this.state);\n      },\n    );\n  }\n\n  onLayoutSave(breakpoint) {\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    mosaic_layout[\n      breakpoint ? breakpoint : 'lg'\n    ] = this.state.activeMosaicLayout;\n\n    this.setState(\n      {\n        // activeMosaicLayout: mosaic_layout,\n        formData: {\n          ...this.state.formData,\n          blocks_layout: {\n            ...this.state.formData.blocks_layout,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('Set state on layout save', this.state);\n      },\n    );\n  }\n\n  onLayoutDelete(breakpoint) {\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    delete mosaic_layout[breakpoint];\n\n    this.setState(\n      {\n        activeMosaicLayout: mosaic_layout['lg'],\n        formData: {\n          ...this.state.formData,\n          blocks_layout: {\n            ...this.state.formData.blocks_layout,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('Set state on change layout', this.state);\n      },\n    );\n  }\n\n  getBlockClass(block) {\n    return (\n      'block-info-data block-edit-' + (block.mosaic_box_sizing || 'fit-content')\n    );\n  }\n\n  createElement(el) {\n    const blockid = el.i;\n\n    // const removeStyle = {\n    //   position: 'absolute',\n    //   right: '2px',\n    //   top: 0,\n    //   cursor: 'pointer',\n    // };\n    const i = el.add ? '+' : el.i;\n    const ref = this.state.refs[blockid];\n\n    return (\n      <div key={i} data-grid={el}>\n        {this.state.preview ? (\n          <BlockViewWrapper\n            useref={ref}\n            formData={this.state.formData}\n            blockid={blockid}\n            showUpdate={this.onShowBlock}\n          />\n        ) : (\n          this.renderEditBlockPlaceholder(el, blockid)\n        )}\n      </div>\n    );\n  }\n\n  renderEditBlockPlaceholder(el, blockid) {\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    let block = formData[blocksFieldname][blockid];\n    const hasData = block['@type'] !== 'text';\n    const i = el.add ? '+' : el.i; // what is this?\n\n    let title = '';\n\n    if (!blocks.blocksConfig[block['@type']]) {\n      console.log(\n        'could not find configuration for this block type',\n        block['@type'],\n      );\n      title = 'broken block';\n    } else {\n      title = block.mosaic_block_title || blocks.blocksConfig[block['@type']].title;\n    }\n\n    return (\n      <div\n        className={hasData ? 'block-edit-wrapper empty' : 'block-edit-wrapper'}\n      >\n        <div className={this.getBlockClass(block)}>\n          {el.h > 2 && (\n            <div className=\"block-size-info\">\n              {el.w} cols x {el.h} rows\n            </div>\n          )}\n          <div>\n            {el.h > 2 && (\n              <div>\n                <h4>{title}</h4>\n              </div>\n            )}\n            <Button.Group size=\"mini\">\n              <Button\n                size=\"mini\"\n                icon\n                color=\"green\"\n                onClick={() => this.handleOpen(blockid)}\n              >\n                <Icon name={editIcon} size=\"10\" />\n              </Button>\n              {this.state.activeScreenSize === 'lg' && (\n                <Button\n                  size=\"mini\"\n                  icon\n                  color=\"red\"\n                  onClick={this.onRemoveItem.bind(this, i)}\n                >\n                  <Icon name={deleteIcon} size=\"10\" />\n                </Button>\n              )}\n            </Button.Group>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  onRemoveItem(id) {\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    const activeMosaicLayout = _.reject(this.state.activeMosaicLayout, {\n      i: id,\n    });\n\n    // mosaic_layout[this.state.activeScreenSize] = activeMosaicLayout;\n    Object.keys(mosaic_layout).forEach(k => {\n      mosaic_layout[k] = _.reject(mosaic_layout[k], { i: id });\n    });\n\n    this.setState(\n      {\n        activeMosaicLayout,\n        formData: {\n          ...this.state.formData,\n          [blocksLayoutFieldname]: {\n            items: without(layoutField.items, id),\n            mosaic_layout, // TODO: might need JSON.stringify?\n          },\n          [blocksFieldname]: omit(this.state.formData[blocksFieldname], [id]),\n        },\n      },\n      () => {\n        console.log('state on removeitem', this.state);\n      },\n    );\n  }\n\n  onChangeField(id, value) {\n    // Handles changes in the normal Volto metadata editor\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [id]: value || null,\n        },\n      },\n      () => {\n        console.log('change state in onChangeField', this.state);\n      },\n    );\n  }\n\n  onMutateBlock(id, value) {\n    // TODO: what does this do? Explain\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n    const activeMosaicLayout = this.state.activeMosaicLayout;\n    mosaic_layout[this.state.activeScreenSize] = activeMosaicLayout;\n\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [id]: value || null,\n          },\n          [blocksLayoutFieldname]: {\n            items: this.state.formData[blocksLayoutFieldname].items,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('change state in onMutateBlock', this.state);\n      },\n    );\n  }\n\n  onAddBlock(type, index) {\n    // Handles the creation of a new block in the layout editor\n    const id = uuid();\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n\n    // const totalItems = formData[blocksLayoutFieldname].items.length;\n    // const insert = index === -1 ? totalItems : index;\n\n    const newBlock = {\n      i: id,\n      x: 0,\n      y: Infinity, // puts it at the bottom\n      w: this.state.cols || 2,\n      h: 2,\n    };\n    const newLayout = this.state.activeMosaicLayout.concat(newBlock);\n\n    let mosaic_layout = layoutField.mosaic_layout || {};\n\n    /// avoids ugly BBB situation\n    if (typeof mosaic_layout === typeof []) mosaic_layout = {};\n    mosaic_layout[this.state.activeScreenSize] = newLayout;\n\n    this.setState(\n      {\n        // Add a new item. It must have a unique key!\n        activeMosaicLayout: newLayout,\n\n        refs: {\n          ...this.state.refs,\n          [id]: React.createRef(),\n        },\n        // Increment the counter to ensure key is always unique.\n        formData: {\n          ...this.state.formData,\n          [blocksLayoutFieldname]: {\n            items: [\n              ...(this.state.formData[blocksLayoutFieldname].items || []),\n              id,\n            ],\n            mosaic_layout: { ...mosaic_layout },\n          },\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [id]: {\n              '@type': type,\n            },\n          },\n        },\n      },\n      () => {\n        console.log('After onAdd', this.state);\n      },\n    );\n    return id;\n  }\n\n  onSubmit(event) {\n    if (event) {\n      event.preventDefault();\n    }\n    const errors = {};\n    map(this.props.schema.fieldsets, fieldset =>\n      map(fieldset.fields, fieldId => {\n        const field = this.props.schema.properties[fieldId];\n        const data = this.state.formData[fieldId];\n        if (this.props.schema.required.indexOf(fieldId) !== -1) {\n          if (field.type !== 'boolean' && !data) {\n            errors[fieldId] = errors[field] || [];\n            errors[fieldId].push(\n              this.props.intl.formatMessage(messages.required),\n            );\n          }\n          if (field.minLength && data.length < field.minLength) {\n            errors[fieldId] = errors[field] || [];\n            errors[fieldId].push(\n              this.props.intl.formatMessage(messages.minLength, {\n                len: field.minLength,\n              }),\n            );\n          }\n        }\n        if (field.uniqueItems && data && uniq(data).length !== data.length) {\n          errors[fieldId] = errors[field] || [];\n          errors[fieldId].push(\n            this.props.intl.formatMessage(messages.uniqueItems),\n          );\n        }\n      }),\n    );\n    if (keys(errors).length > 0) {\n      this.setState({\n        errors,\n      });\n    } else {\n      this.props.onSubmit(this.state.formData);\n      if (this.props.resetAfterSubmit) {\n        this.setState({\n          formData: this.props.formData,\n        });\n      }\n    }\n  }\n\n  handleLayoutToolbar(evType, data) {\n    // console.log('handleLayoutToolbar', evType, data);\n\n    switch (evType) {\n      case 'PREVIEW_TILES':\n        this.setState({\n          preview: data,\n        });\n        break;\n      case 'CHANGE_SCREEN_SIZE':\n        const formData = this.state.formData;\n        const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n        const layoutField = formData[blocksLayoutFieldname];\n        const layouts = layoutField.mosaic_layout || {};\n\n        let fallback = layouts['lg']\n          ? JSON.parse(JSON.stringify(layouts['lg']))\n          : [];\n\n        const activeMosaicLayout = layouts[data] || fallback;\n        let layoutWidth = breakpoints[data];\n        if (data === 'lg') {\n          layoutWidth = null;\n        } else if (data === 'xxs') {\n          layoutWidth = breakpoints['xs'] - 20;\n        }\n        console.log('Change screen', data, layoutWidth, layouts);\n        // TODO: this needs to be improved. We want to automatically take\n        // size from (<next upper breakpoint> -1)\n\n        this.setState(\n          {\n            activeMosaicLayout,\n            dirtyLayout: false, // This could be used to show that layout\n            // will be saved\n            activeScreenSize: data,\n            layoutWidth,\n          },\n          // this.changeLayoutOnScreenSizeChange(data),\n        );\n        break;\n      case 'CREATE_TILE':\n        this.onAddBlock('text');\n        break;\n      case 'CREATE_LAYOUT':\n        // console.log('herere', this.state);\n        this.onLayoutSave(data);\n        break;\n      case 'DELETE_LAYOUT':\n        this.onLayoutDelete(data);\n        break;\n      default:\n        break;\n    }\n  }\n\n  render() {\n    const { schema } = this.props; // , onCancel, onSubmit\n    console.log('render props', this.props);\n\n    return __CLIENT__ ? (\n      <div className=\"ui wrapper\">\n        <LayoutToolbar\n          availableScreens={this.state.availableScreens}\n          layouts={\n            this.state.formData.blocks_layout.mosaic_layout ||\n            this.props.formData.blocks_layout.mosaic_layout\n          }\n          preview={this.state.preview}\n          activeMosaicLayout={this.state.activeMosaicLayout}\n          dispatchToParent={this.handleLayoutToolbar}\n        />\n\n        <div\n          className=\"layout-preview\"\n          id={'layout-preview-' + this.state.activeScreenSize}\n        >\n          <SizeMe>\n            {({ size }) => (\n              <ReactGridLayout\n                onLayoutChange={this.onLayoutChange}\n                onBreakpointChange={this.onBreakpointChange}\n                layout={this.state.activeMosaicLayout}\n                width={\n                  this.state.layoutWidth ||\n                  size.width ||\n                  document.querySelector('main').offsetWidth\n                }\n                onDragStop={this.onDragStop}\n                onResizeStop={this.onResizeStop}\n                onResize={this.onResize}\n                onResizeStart={this.onResizeStart}\n                {...this.props}\n              >\n                {_.map(this.state.activeMosaicLayout, el =>\n                  this.createElement(el),\n                )}\n              </ReactGridLayout>\n            )}\n          </SizeMe>\n        </div>\n\n        {/* onChangeBlock={this.onEditBlock} */}\n        {this.state.showModal ? (\n          <BlockEditor\n            blockid={this.state.currentBlock}\n            formData={this.state.formData}\n            onClose={this.handleCloseEditor}\n          />\n        ) : (\n          ''\n        )}\n\n        <Portal\n          node={__CLIENT__ && document.getElementById('sidebar-properties')}\n        >\n          <UiForm>\n            <Segment secondary attached>\n              Layout properties\n            </Segment>\n            <Segment attached>\n              <Field\n                id=\"layout-css\"\n                title=\"CSS Overrides\"\n                value={\n                  this.state.formData.blocks_layout?.mosaic_layout\n                    ?.mosaic_css_override || ''\n                }\n                description=\"Custom css for this layout page\"\n                widget=\"textarea\"\n                required={false}\n                onChange={(id, value) => {\n                  this.setState({\n                    formData: {\n                      ...this.state.formData,\n                      blocks_layout: {\n                        ...this.state.formData.blocks_layout,\n                        mosaic_layout: {\n                          ...(this.state.formData.blocks_layout?.mosaic_layout ||\n                            {}),\n                          mosaic_css_override: value,\n                        },\n                      },\n                    },\n                  });\n                }}\n              />\n            </Segment>\n          </UiForm>\n        </Portal>\n\n        <Portal\n          node={__CLIENT__ && document.getElementById('sidebar-metadata')}\n        >\n          <UiForm\n            method=\"post\"\n            onSubmit={this.onSubmit}\n            error={keys(this.state.errors).length > 0}\n          >\n            {schema &&\n              map(schema.fieldsets, item => [\n                <Segment secondary attached key={item.title}>\n                  {item.title}\n                </Segment>,\n                <Segment attached key={`fieldset-contents-${item.title}`}>\n                  {map(item.fields, (field, index) => (\n                    <Field\n                      {...schema.properties[field]}\n                      id={field}\n                      focus={index === 0}\n                      value={this.state.formData[field]}\n                      required={schema.required.indexOf(field) !== -1}\n                      onChange={this.onChangeField}\n                      key={field}\n                      error={this.state.errors[field]}\n                    />\n                  ))}\n                </Segment>,\n              ])}\n          </UiForm>\n        </Portal>\n      </div>\n    ) : (\n      ''\n    );\n  }\n\n  onResizeStop(layout, old, neu, x, e, node) {\n    // console.log('on resize stop'); //, layout, oldDragItem, l, x, e, node);\n\n    let dW = neu.w - old.w; // negative if size made smaller\n    layout.forEach((el, i) => {\n      if (el.i === neu.i) return;\n\n      if (el.x === old.x + old.w) {\n        // dragged from right side, to left\n        console.log('resizeToLeft w x', dW, el.w, el.x);\n        el.x = neu.x + neu.w;\n        el.w -= neu.w - old.w;\n      }\n      // else if (el.x - dW === neu.x + neu.w) {\n      //   // resized original to left\n      //   console.log('resizeToRight w x', dW, el.w, el.x);\n      //   el.x -= dW;\n      //   el.w += dW;\n      // }\n    });\n\n    // if the height has changed, set sizing policy for this layout to manual\n    const blockid = old.i;\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    this.setState(\n      (state, props) => {\n        const blockData = state.formData[blocksFieldname][blockid] || {};\n        let mosaic_box_sizing = blockData.mosaic_box_sizing || 'fit-content';\n        if (neu.h !== old.h) mosaic_box_sizing = 'manual';\n        return {\n          dirtyLayout: true,\n          formData: {\n            ...state.formData,\n            [blocksFieldname]: {\n              ...state.formData[blocksFieldname],\n              [blockid]: {\n                ...state.formData[blocksFieldname][blockid],\n                mosaic_box_sizing,\n              },\n            },\n          },\n        };\n      },\n      () => {\n        // console.log('after resize', this.state);\n      },\n    );\n  }\n\n  onDragStop(layout, old, neu, x, e, node) {\n    // console.log('on drag stop'); // , layout, oldDragItem, l, x, e, node);\n    this.setState({\n      dirtyLayout: true,\n    });\n  }\n\n  // onResize(layout, old, neu, x, e, node) {\n  // console.log(\n  //   'on resize layout, oldDragItem, l, x, e, node',\n  //   layout,\n  //   oO, // oldDragItem, the element that was dragged\n  //   nO, // new dragged item, the element that became new\n  //   x,\n  //   e,\n  //   node,\n  // );\n  // let startH = neu.y;\n  // let endH = neu.y + neu.h;\n  // console.log('resize', layout, old, neu);\n  // TODO: find all elements that are on the same \"row\"\n  // change width of elements only if they are dW units \"left behind\"\n  // console.log('on resize');\n  // }\n\n  // onResizeStart(layout, oldDragItem, l, x, e, node) {\n  //   console.log('on resize start'); //, layout, oldDragItem, l, x, e, node);\n  //   // TODO: identify affected blocks, keep them in state, update their size\n  // }\n\n  // onDrag(layout, oldDragItem, l, x, e, node) {\n  //   // console.log(\n  //   //   'on drag layout, oldDragItem, l, x, e, node',\n  //   //   layout,\n  //   //   oldDragItem,\n  //   //   l,\n  //   //   x,\n  //   //   // e,\n  //   //   // node,\n  //   // );\n  // }\n\n  // onDragStart(layout, oldDragItem, l, x, e, node) {\n  //   // console.log('on drag start'); //, layout, oldDragItem, l, x, e, node);\n  // }\n\n  // onEditBlock(id, value, size) {\n  //   // Handles editing of block by the block editor\n  //   const blocksFieldname = getBlocksFieldname(this.state.formData);\n  //   this.setState({\n  //     formData: {\n  //       ...this.state.formData,\n  //       [blocksFieldname]: {\n  //         ...this.state.formData[blocksFieldname],\n  //         [id]: value || null,\n  //       },\n  //     },\n  //   });\n  // }\n}\n\nexport default injectIntl(Form, { forwardRef: true });\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AA+BA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAGA;AACA;AAjCA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AA3BA;AA4BA;AACA;;;AAQA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAAA;AAAA;AAAA;AAAA;AAqBA;;;AAEA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AACA;AAIA;AACA;AANA;AAQA;;;AAEA;AACA;AAEA;AACA;AAEA;AADA;AAQA;AAEA;;;AAEA;AACA;AACA;AAEA;AACA;AADA;AAMA;;;AAEA;AAAA;AACA;AACA;AADA;AAGA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAKA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAFA;AAFA;AAdA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;;AAtNA;AACA;AAwNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AA7BA;AACA;AAmCA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AACA;;;;;AA6DA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAFA;AALA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA7FA;AA8FA;AACA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAOA;AACA;AATA;AAYA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AAJA;AAUA;AAXA;AAaA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAnDA;AAqDA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAJA;AAFA;AAaA;AAEA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AAFA;AAWA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AAFA;AAWA;AACA;AAEA;;;AAEA;AACA;AAGA;;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAWA;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAHA;AAJA;AAYA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AADA;AAOA;AACA;AAEA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AAFA;AAPA;AAcA;AACA;AAEA;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AAGA;AAIA;AALA;AAUA;AADA;AApBA;AA2BA;AACA;AAEA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AADA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AA1BA;AACA;AA2BA;AACA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AALA;AADA;AAUA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAjDA;AAmDA;;;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AACA;AAEA,+BAoGA;AAyBA;;;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AANA;AAFA;AAaA;AAGA;AAEA;;;AAEA;AACA;AACA;AACA;AADA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAt6BA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AA3BA;AACA;AAFA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AA5BA;AACA;AAw4BA;AAAA;AAAA;;;;A","sourceRoot":""}