{"version":3,"file":"main.54536aeccaccd8e9284b.hot-update.js","sources":["webpack:///./volto-mosaic/src/components/manage/Form.jsx","webpack:///./volto-mosaic/src/components/manage/LayoutToolbar.jsx","webpack:///./volto-mosaic/src/components/theme/View.jsx"],"sourcesContent":["// import ReactDOM from 'react-dom';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { keys, map, mapValues, omit, uniq, without } from 'lodash';\nimport { Button, Form as UiForm, Segment } from 'semantic-ui-react';\nimport { defineMessages, injectIntl } from 'react-intl';\nimport { v4 as uuid } from 'uuid';\nimport { Portal } from 'react-portal';\n\nimport { Field, Icon } from '@plone/volto/components'; // EditBlock\nimport {\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\n\nimport _ from 'lodash';\n\nimport RGL from 'react-grid-layout';\n\nimport 'react-grid-layout/css/styles.css';\nimport 'react-resizable/css/styles.css';\n\nimport { SizeMe } from 'react-sizeme';\n\nimport '../css/edit.css';\nimport '../css/view.css';\n\nimport { rowHeight, breakpoints, screenSizes } from '../../config';\n\nimport BlockEditor from './BlockEditor';\nimport LayoutToolbar from './LayoutToolbar';\nimport { BlockViewWrapper } from './../theme/View';\n\nimport deleteIcon from '@plone/volto/icons/delete.svg';\nimport editIcon from '@plone/volto/icons/editing.svg';\n\nimport { blocks } from '~/config';\n// import move from 'lodash-move';\n// import aheadSVG from '@plone/volto/icons/ahead.svg';\n// import clearSVG from '@plone/volto/icons/clear.svg';\nconst ReactGridLayout = RGL;\n\nconst screens = Object.keys(screenSizes).map(k => {\n  return { key: k, text: screenSizes[k], value: k };\n});\n\nconst messages = defineMessages({\n  addBlock: {\n    id: 'Add tile...',\n    defaultMessage: 'Add tile...',\n  },\n  required: {\n    id: 'Required input is missing.',\n    defaultMessage: 'Required input is missing.',\n  },\n  minLength: {\n    id: 'Minimum length is {len}.',\n    defaultMessage: 'Minimum length is {len}.',\n  },\n  uniqueItems: {\n    id: 'Items must be unique.',\n    defaultMessage: 'Items must be unique.',\n  },\n  save: {\n    id: 'Save',\n    defaultMessage: 'Save',\n  },\n  cancel: {\n    id: 'Cancel',\n    defaultMessage: 'Cancel',\n  },\n  error: {\n    id: 'Error',\n    defaultMessage: 'Error',\n  },\n  thereWereSomeErrors: {\n    id: 'There were some errors.',\n    defaultMessage: 'There were some errors.',\n  },\n});\n\n// Instead of Object.fromEntries\nfunction fromEntries(iterable) {\n  return [...iterable].reduce((obj, [key, val]) => {\n    obj[key] = val;\n    return obj;\n  }, {});\n}\n\nfunction fallbackLayoutFromData(formData, ids) {\n  // create a default layout based on existing blocks\n\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  const order = formData[blocksLayoutFieldname].items || [];\n  const data = formData[blocksFieldname];\n\n  const fallbackLayout = [\n    {\n      // provide default tile for title\n      h: 1,\n      i: ids.title,\n      w: 12,\n      x: 0,\n      y: 0,\n    },\n    {\n      // provide default tile for text\n      h: 3,\n      i: ids.text,\n      w: 12,\n      x: 0,\n      y: 1,\n    },\n  ];\n\n  const validIds = order.filter(i => {\n    return Object.keys(data).indexOf(i) > -1;\n  });\n  const res = validIds.map((el, ix) => {\n    return {\n      w: 12,\n      h: ix === 0 ? 2 : 4,\n      x: 0,\n      y: ix === 0 ? 0 : 2 + (ix - 1) * 4,\n      i: el,\n    };\n  });\n\n  return res || fallbackLayout;\n}\n\nclass Form extends Component {\n  static propTypes = {\n    schema: PropTypes.shape({\n      fieldsets: PropTypes.arrayOf(\n        PropTypes.shape({\n          fields: PropTypes.arrayOf(PropTypes.string),\n          id: PropTypes.string,\n          title: PropTypes.string,\n        }),\n      ),\n      properties: PropTypes.objectOf(PropTypes.any),\n      definitions: PropTypes.objectOf(PropTypes.any),\n      required: PropTypes.arrayOf(PropTypes.string),\n    }),\n    formData: PropTypes.objectOf(PropTypes.any),\n    pathname: PropTypes.string,\n    onSubmit: PropTypes.func,\n    onCancel: PropTypes.func,\n    submitLabel: PropTypes.string,\n    resetAfterSubmit: PropTypes.bool,\n    title: PropTypes.string,\n    error: PropTypes.shape({\n      message: PropTypes.string,\n    }),\n    loading: PropTypes.bool,\n    hideActions: PropTypes.bool,\n    description: PropTypes.string,\n    visual: PropTypes.bool,\n    blocks: PropTypes.arrayOf(PropTypes.object),\n  };\n\n  static defaultProps = {\n    description: null,\n    error: null,\n    formData: null,\n    hideActions: false,\n    loading: null,\n    onCancel: null,\n    onSubmit: null,\n    pathname: '',\n    resetAfterSubmit: false,\n    schema: {},\n    submitLabel: null,\n    blocks: [],\n    title: null,\n    visual: false,\n\n    preview: false,\n    // Grid props\n    className: 'mosaic-edit-layout',\n    // cols: { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },\n    // cols: { lg: 12, md: 12, sm: 12, xs: 12, xxs: 12 },\n    cols: 12,\n    rowHeight: rowHeight,\n    margin: [0, 0],\n    layoutWidth: null, // preview responsive layout width\n    activeScreenSize: 'lg', // 'desktop' is the default screen size\n\n    payload: null, // blockData that will be saved\n  };\n\n  constructor(props) {\n    super(props);\n\n    if (__SERVER__) return;\n\n    const ids = {\n      title: uuid(),\n      text: uuid(),\n    };\n    let { formData } = props;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    if (formData === null) {\n      // get defaults from schema\n      formData = mapValues(props.schema.properties, 'default');\n    }\n    // defaults for block editor; should be moved to schema on server side\n    if (!formData[blocksLayoutFieldname]) {\n      formData[blocksLayoutFieldname] = {\n        items: [ids.title, ids.text],\n      };\n    }\n    if (!formData[blocksFieldname]) {\n      formData[blocksFieldname] = {\n        [ids.title]: {\n          '@type': 'title',\n          mosaic_tile_title: 'title tile',\n        },\n        [ids.text]: {\n          '@type': 'text',\n          mosaic_tile_title: 'text tile',\n        },\n      };\n    }\n\n    const activeScreenSize = this.props.activeScreenSize;\n    // TODO: rewrite with ? operator\n    const activeMosaicLayout =\n      (this.props.formData &&\n        this.props.formData.blocks_layout &&\n        this.props.formData.blocks_layout.mosaic_layout &&\n        this.props.formData.blocks_layout.mosaic_layout[activeScreenSize]) ||\n      fallbackLayoutFromData(formData, ids);\n\n    if (!formData[blocksLayoutFieldname].mosaic_layout) {\n      formData[blocksLayoutFieldname].mosaic_layout = {\n        lg: activeMosaicLayout,\n      };\n    }\n\n    const items = formData[blocksLayoutFieldname].items || [];\n    const refs = items.map(id => [id, React.createRef()]);\n\n    this.state = {\n      formData,\n      errors: {},\n      cols: 12,\n      availableScreens: screens,\n      layoutWidth: this.props.layoutWidth,\n      activeScreenSize,\n      activeMosaicLayout,\n      dirtyLayout: false,\n      refs: fromEntries(refs),\n      tileHeights: {},\n    };\n\n    // this.onMoveBlock = this.onMoveBlock.bind(this);\n    // this.onSelectBlock = this.onSelectBlock.bind(this);\n    // this.onDeleteBlock = this.onDeleteBlock.bind(this);\n    // this.onFocusPreviousBlock = this.onFocusPreviousBlock.bind(this);\n    // this.onFocusNextBlock = this.onFocusNextBlock.bind(this);\n    // this.handleKeyDown = this.handleKeyDown.bind(this);\n    // this.onEditBlock = this.onEditBlock.bind(this);\n    // this.renderBlockPreview = this.renderBlockPreview.bind(this);\n    // this.onDragStart = this.onDragStart.bind(this);\n    // this.onDrag = this.onDrag.bind(this);\n    // this.onResize = this.onResize.bind(this);\n    // this.onResizeStart = this.onResizeStart.bind(this);\n\n    this.onDragStop = this.onDragStop.bind(this);\n    this.onResizeStop = this.onResizeStop.bind(this);\n\n    this.onChangeField = this.onChangeField.bind(this);\n    this.onMutateBlock = this.onMutateBlock.bind(this);\n    this.onAddBlock = this.onAddBlock.bind(this);\n    this.onSubmit = this.onSubmit.bind(this);\n\n    this.createElement = this.createElement.bind(this);\n    this.onLayoutChange = this.onLayoutChange.bind(this);\n    this.handleOpen = this.handleOpen.bind(this);\n    this.handleCloseEditor = this.handleCloseEditor.bind(this);\n    this.handleLayoutToolbar = this.handleLayoutToolbar.bind(this);\n    this.onShowBlock = this.onShowBlock.bind(this);\n  }\n\n  handleOpen(tileid) {\n    this.setState({ showModal: true, currentBlock: tileid, tileHeights: {} });\n  }\n\n  handleCloseEditor(blockData) {\n    if (!blockData) {\n      this.setState({\n        showModal: false,\n        currentBlock: null,\n      });\n      return;\n    }\n\n    const tileid = this.state.currentBlock;\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [tileid]: blockData || null,\n          },\n        },\n        showModal: false,\n        preview: true,\n      },\n      () => {\n        console.log('state after handleCloseEditor', this.state);\n      },\n    );\n  }\n\n  onShowBlock(tileid, height) {\n    const formData = this.state.formData;\n\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const activeScreenSize = this.state.activeScreenSize || 'lg';\n    const blockData = formData[blocksFieldname][tileid];\n\n    const sizing = blockData.mosaic_box_sizing || 'fit-content';\n\n    let ix, lh;\n    switch (sizing) {\n      case 'fit-content':\n        this.setState(\n          (state, props) => {\n            const activeMosaicLayout = JSON.parse(\n              JSON.stringify(state.activeMosaicLayout),\n            );\n            lh = Math.ceil(height / this.props.rowHeight);\n            ix = activeMosaicLayout.indexOf(\n              activeMosaicLayout.find(el => {\n                return el.i === tileid;\n              }),\n            );\n            activeMosaicLayout[ix].h = lh;\n            return {\n              formData: {\n                ...state.formData,\n                [blocksLayoutFieldname]: {\n                  ...layoutField,\n                  mosaic_layout: {\n                    ...layoutField.mosaic_layout,\n                    [activeScreenSize]: activeMosaicLayout,\n                  },\n                },\n              },\n              activeMosaicLayout,\n            };\n          },\n          () => {\n            console.log('height of node', height, lh, tileid, this.state);\n          },\n        );\n        break;\n\n      // case 'min-height':\n      //   // TODO: get minimum tile height from settings, trigger layout update\n      //   const type = formData['@type'].toLowerCase();\n      //   const minHeight = blocks.blocksConfig[type].height || 100;\n      //   height = Math.ceil(minHeight / this.props.rowHeight);\n      //   ix = activeMosaicLayout.indexOf(\n      //     activeMosaicLayout.find(el => {\n      //       return el.i === tileid;\n      //     }),\n      //   );\n      //   activeMosaicLayout[ix].h = height;\n      //   break;\n      case 'fill-space':\n        break;\n      case 'manual':\n        break;\n      default:\n        break;\n    }\n  }\n\n  onLayoutChange(newLayout) {\n    console.log('on layout change');\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    const size = this.state.activeScreenSize;\n\n    // Layout hasn't been created yet\n    if (Object.keys(mosaic_layout).indexOf(size) === -1) {\n      this.setState({\n        activeMosaicLayout: newLayout,\n      });\n      return;\n    }\n\n    this.setState(\n      (state, props) => {\n        return {\n          activeMosaicLayout: newLayout,\n          formData: {\n            ...state.formData,\n            [blocksLayoutFieldname]: {\n              ...state.formData[blocksLayoutFieldname],\n              mosaic_layout: {\n                ...state.formData[blocksLayoutFieldname].mosaic_layout,\n                [size]: newLayout,\n              },\n            },\n          },\n        };\n      },\n      () => {\n        console.log('Set state on change layout ' + size, this.state);\n      },\n    );\n  }\n\n  onLayoutSave(breakpoint) {\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    mosaic_layout[\n      breakpoint ? breakpoint : 'lg'\n    ] = this.state.activeMosaicLayout;\n\n    this.setState(\n      {\n        // activeMosaicLayout: mosaic_layout,\n        formData: {\n          ...this.state.formData,\n          blocks_layout: {\n            ...this.state.formData.blocks_layout,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('Set state on layout save', this.state);\n      },\n    );\n  }\n\n  onLayoutDelete(breakpoint) {\n    const formData = this.state.formData;\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    delete mosaic_layout[breakpoint];\n\n    this.setState(\n      {\n        activeMosaicLayout: mosaic_layout['lg'],\n        formData: {\n          ...this.state.formData,\n          blocks_layout: {\n            ...this.state.formData.blocks_layout,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('Set state on change layout', this.state);\n      },\n    );\n  }\n\n  getBlockClass(tile) {\n    return (\n      'tile-info-data tile-edit-' + (tile.mosaic_box_sizing || 'fit-content')\n    );\n  }\n\n  createElement(el) {\n    const tileid = el.i;\n\n    // const removeStyle = {\n    //   position: 'absolute',\n    //   right: '2px',\n    //   top: 0,\n    //   cursor: 'pointer',\n    // };\n    const i = el.add ? '+' : el.i;\n    const ref = this.state.refs[tileid];\n\n    return (\n      <div key={i} data-grid={el}>\n        {this.state.preview ? (\n          <BlockViewWrapper\n            useref={ref}\n            formData={this.state.formData}\n            tileid={tileid}\n            showUpdate={this.onShowBlock}\n          />\n        ) : (\n          this.renderEditBlockPlaceholder(el, tileid)\n        )}\n      </div>\n    );\n  }\n\n  renderEditBlockPlaceholder(el, tileid) {\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    let tile = formData[blocksFieldname][tileid];\n    const hasData = tile['@type'] !== 'text';\n    const i = el.add ? '+' : el.i; // what is this?\n\n    let title = '';\n\n    if (!blocks.blocksConfig[tile['@type']]) {\n      console.log(\n        'could not find configuration for this tile type',\n        tile['@type'],\n      );\n      title = 'broken tile';\n    } else {\n      title = tile.mosaic_tile_title || blocks.blocksConfig[tile['@type']].title;\n    }\n\n    return (\n      <div\n        className={hasData ? 'tile-edit-wrapper empty' : 'tile-edit-wrapper'}\n      >\n        <div className={this.getBlockClass(tile)}>\n          {el.h > 2 && (\n            <div className=\"tile-size-info\">\n              {el.w} cols x {el.h} rows\n            </div>\n          )}\n          <div>\n            {el.h > 2 && (\n              <div>\n                <h4>{title}</h4>\n              </div>\n            )}\n            <Button.Group size=\"mini\">\n              <Button\n                size=\"mini\"\n                icon\n                color=\"green\"\n                onClick={() => this.handleOpen(tileid)}\n              >\n                <Icon name={editIcon} size=\"10\" />\n              </Button>\n              {this.state.activeScreenSize === 'lg' && (\n                <Button\n                  size=\"mini\"\n                  icon\n                  color=\"red\"\n                  onClick={this.onRemoveItem.bind(this, i)}\n                >\n                  <Icon name={deleteIcon} size=\"10\" />\n                </Button>\n              )}\n            </Button.Group>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  onRemoveItem(id) {\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n\n    const activeMosaicLayout = _.reject(this.state.activeMosaicLayout, {\n      i: id,\n    });\n\n    // mosaic_layout[this.state.activeScreenSize] = activeMosaicLayout;\n    Object.keys(mosaic_layout).forEach(k => {\n      mosaic_layout[k] = _.reject(mosaic_layout[k], { i: id });\n    });\n\n    this.setState(\n      {\n        activeMosaicLayout,\n        formData: {\n          ...this.state.formData,\n          [blocksLayoutFieldname]: {\n            items: without(layoutField.items, id),\n            mosaic_layout, // TODO: might need JSON.stringify?\n          },\n          [blocksFieldname]: omit(this.state.formData[blocksFieldname], [id]),\n        },\n      },\n      () => {\n        console.log('state on removeitem', this.state);\n      },\n    );\n  }\n\n  onChangeField(id, value) {\n    // Handles changes in the normal Volto metadata editor\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [id]: value || null,\n        },\n      },\n      () => {\n        console.log('change state in onChangeField', this.state);\n      },\n    );\n  }\n\n  onMutateBlock(id, value) {\n    // TODO: what does this do? Explain\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n    const layoutField = formData[blocksLayoutFieldname];\n    const mosaic_layout = layoutField.mosaic_layout || {};\n    const activeMosaicLayout = this.state.activeMosaicLayout;\n    mosaic_layout[this.state.activeScreenSize] = activeMosaicLayout;\n\n    this.setState(\n      {\n        formData: {\n          ...this.state.formData,\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [id]: value || null,\n          },\n          [blocksLayoutFieldname]: {\n            items: this.state.formData[blocksLayoutFieldname].items,\n            mosaic_layout,\n          },\n        },\n      },\n      () => {\n        console.log('change state in onMutateBlock', this.state);\n      },\n    );\n  }\n\n  onAddBlock(type, index) {\n    // Handles the creation of a new tile in the layout editor\n    const id = uuid();\n\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n    const layoutField = formData[blocksLayoutFieldname];\n\n    // const totalItems = formData[blocksLayoutFieldname].items.length;\n    // const insert = index === -1 ? totalItems : index;\n\n    const newBlock = {\n      i: id,\n      x: 0,\n      y: Infinity, // puts it at the bottom\n      w: this.state.cols || 2,\n      h: 2,\n    };\n    const newLayout = this.state.activeMosaicLayout.concat(newBlock);\n\n    let mosaic_layout = layoutField.mosaic_layout || {};\n\n    /// avoids ugly BBB situation\n    if (typeof mosaic_layout === typeof []) mosaic_layout = {};\n    mosaic_layout[this.state.activeScreenSize] = newLayout;\n\n    this.setState(\n      {\n        // Add a new item. It must have a unique key!\n        activeMosaicLayout: newLayout,\n\n        refs: {\n          ...this.state.refs,\n          [id]: React.createRef(),\n        },\n        // Increment the counter to ensure key is always unique.\n        formData: {\n          ...this.state.formData,\n          [blocksLayoutFieldname]: {\n            items: [\n              ...(this.state.formData[blocksLayoutFieldname].items || []),\n              id,\n            ],\n            mosaic_layout: { ...mosaic_layout },\n          },\n          [blocksFieldname]: {\n            ...this.state.formData[blocksFieldname],\n            [id]: {\n              '@type': type,\n            },\n          },\n        },\n      },\n      () => {\n        console.log('After onAdd', this.state);\n      },\n    );\n    return id;\n  }\n\n  onSubmit(event) {\n    if (event) {\n      event.preventDefault();\n    }\n    const errors = {};\n    map(this.props.schema.fieldsets, fieldset =>\n      map(fieldset.fields, fieldId => {\n        const field = this.props.schema.properties[fieldId];\n        const data = this.state.formData[fieldId];\n        if (this.props.schema.required.indexOf(fieldId) !== -1) {\n          if (field.type !== 'boolean' && !data) {\n            errors[fieldId] = errors[field] || [];\n            errors[fieldId].push(\n              this.props.intl.formatMessage(messages.required),\n            );\n          }\n          if (field.minLength && data.length < field.minLength) {\n            errors[fieldId] = errors[field] || [];\n            errors[fieldId].push(\n              this.props.intl.formatMessage(messages.minLength, {\n                len: field.minLength,\n              }),\n            );\n          }\n        }\n        if (field.uniqueItems && data && uniq(data).length !== data.length) {\n          errors[fieldId] = errors[field] || [];\n          errors[fieldId].push(\n            this.props.intl.formatMessage(messages.uniqueItems),\n          );\n        }\n      }),\n    );\n    if (keys(errors).length > 0) {\n      this.setState({\n        errors,\n      });\n    } else {\n      this.props.onSubmit(this.state.formData);\n      if (this.props.resetAfterSubmit) {\n        this.setState({\n          formData: this.props.formData,\n        });\n      }\n    }\n  }\n\n  handleLayoutToolbar(evType, data) {\n    // console.log('handleLayoutToolbar', evType, data);\n\n    switch (evType) {\n      case 'PREVIEW_TILES':\n        this.setState({\n          preview: data,\n        });\n        break;\n      case 'CHANGE_SCREEN_SIZE':\n        const formData = this.state.formData;\n        const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n        const layoutField = formData[blocksLayoutFieldname];\n        const layouts = layoutField.mosaic_layout || {};\n\n        let fallback = layouts['lg']\n          ? JSON.parse(JSON.stringify(layouts['lg']))\n          : [];\n\n        const activeMosaicLayout = layouts[data] || fallback;\n        let layoutWidth = breakpoints[data];\n        if (data === 'lg') {\n          layoutWidth = null;\n        } else if (data === 'xxs') {\n          layoutWidth = breakpoints['xs'] - 20;\n        }\n        console.log('Change screen', data, layoutWidth, layouts);\n        // TODO: this needs to be improved. We want to automatically take\n        // size from (<next upper breakpoint> -1)\n\n        this.setState(\n          {\n            activeMosaicLayout,\n            dirtyLayout: false, // This could be used to show that layout\n            // will be saved\n            activeScreenSize: data,\n            layoutWidth,\n          },\n          // this.changeLayoutOnScreenSizeChange(data),\n        );\n        break;\n      case 'CREATE_TILE':\n        this.onAddBlock('text');\n        break;\n      case 'CREATE_LAYOUT':\n        // console.log('herere', this.state);\n        this.onLayoutSave(data);\n        break;\n      case 'DELETE_LAYOUT':\n        this.onLayoutDelete(data);\n        break;\n      default:\n        break;\n    }\n  }\n\n  render() {\n    const { schema } = this.props; // , onCancel, onSubmit\n    console.log('render props', this.props);\n\n    return __CLIENT__ ? (\n      <div className=\"ui wrapper\">\n        <LayoutToolbar\n          availableScreens={this.state.availableScreens}\n          layouts={\n            this.state.formData.blocks_layout.mosaic_layout ||\n            this.props.formData.blocks_layout.mosaic_layout\n          }\n          preview={this.state.preview}\n          activeMosaicLayout={this.state.activeMosaicLayout}\n          dispatchToParent={this.handleLayoutToolbar}\n        />\n\n        <div\n          className=\"layout-preview\"\n          id={'layout-preview-' + this.state.activeScreenSize}\n        >\n          <SizeMe>\n            {({ size }) => (\n              <ReactGridLayout\n                onLayoutChange={this.onLayoutChange}\n                onBreakpointChange={this.onBreakpointChange}\n                layout={this.state.activeMosaicLayout}\n                width={\n                  this.state.layoutWidth ||\n                  size.width ||\n                  document.querySelector('main').offsetWidth\n                }\n                onDragStop={this.onDragStop}\n                onResizeStop={this.onResizeStop}\n                onResize={this.onResize}\n                onResizeStart={this.onResizeStart}\n                {...this.props}\n              >\n                {_.map(this.state.activeMosaicLayout, el =>\n                  this.createElement(el),\n                )}\n              </ReactGridLayout>\n            )}\n          </SizeMe>\n        </div>\n\n        {/* onChangeBlock={this.onEditBlock} */}\n        {this.state.showModal ? (\n          <BlockEditor\n            tileid={this.state.currentBlock}\n            formData={this.state.formData}\n            onClose={this.handleCloseEditor}\n          />\n        ) : (\n          ''\n        )}\n\n        <Portal\n          node={__CLIENT__ && document.getElementById('sidebar-properties')}\n        >\n          <UiForm>\n            <Segment secondary attached>\n              Layout properties\n            </Segment>\n            <Segment attached>\n              <Field\n                id=\"layout-css\"\n                title=\"CSS Overrides\"\n                value={\n                  this.state.formData.blocks_layout?.mosaic_layout\n                    ?.mosaic_css_override || ''\n                }\n                description=\"Custom css for this layout page\"\n                widget=\"textarea\"\n                required={false}\n                onChange={(id, value) => {\n                  this.setState({\n                    formData: {\n                      ...this.state.formData,\n                      blocks_layout: {\n                        ...this.state.formData.blocks_layout,\n                        mosaic_layout: {\n                          ...(this.state.formData.blocks_layout?.mosaic_layout ||\n                            {}),\n                          mosaic_css_override: value,\n                        },\n                      },\n                    },\n                  });\n                }}\n              />\n            </Segment>\n          </UiForm>\n        </Portal>\n\n        <Portal\n          node={__CLIENT__ && document.getElementById('sidebar-metadata')}\n        >\n          <UiForm\n            method=\"post\"\n            onSubmit={this.onSubmit}\n            error={keys(this.state.errors).length > 0}\n          >\n            {schema &&\n              map(schema.fieldsets, item => [\n                <Segment secondary attached key={item.title}>\n                  {item.title}\n                </Segment>,\n                <Segment attached key={`fieldset-contents-${item.title}`}>\n                  {map(item.fields, (field, index) => (\n                    <Field\n                      {...schema.properties[field]}\n                      id={field}\n                      focus={index === 0}\n                      value={this.state.formData[field]}\n                      required={schema.required.indexOf(field) !== -1}\n                      onChange={this.onChangeField}\n                      key={field}\n                      error={this.state.errors[field]}\n                    />\n                  ))}\n                </Segment>,\n              ])}\n          </UiForm>\n        </Portal>\n      </div>\n    ) : (\n      ''\n    );\n  }\n\n  onResizeStop(layout, old, neu, x, e, node) {\n    // console.log('on resize stop'); //, layout, oldDragItem, l, x, e, node);\n\n    let dW = neu.w - old.w; // negative if size made smaller\n    layout.forEach((el, i) => {\n      if (el.i === neu.i) return;\n\n      if (el.x === old.x + old.w) {\n        // dragged from right side, to left\n        console.log('resizeToLeft w x', dW, el.w, el.x);\n        el.x = neu.x + neu.w;\n        el.w -= neu.w - old.w;\n      }\n      // else if (el.x - dW === neu.x + neu.w) {\n      //   // resized original to left\n      //   console.log('resizeToRight w x', dW, el.w, el.x);\n      //   el.x -= dW;\n      //   el.w += dW;\n      // }\n    });\n\n    // if the height has changed, set sizing policy for this layout to manual\n    const tileid = old.i;\n    const formData = this.state.formData;\n    const blocksFieldname = getBlocksFieldname(formData);\n\n    this.setState(\n      (state, props) => {\n        const blockData = state.formData[blocksFieldname][tileid] || {};\n        let mosaic_box_sizing = blockData.mosaic_box_sizing || 'fit-content';\n        if (neu.h !== old.h) mosaic_box_sizing = 'manual';\n        return {\n          dirtyLayout: true,\n          formData: {\n            ...state.formData,\n            [blocksFieldname]: {\n              ...state.formData[blocksFieldname],\n              [tileid]: {\n                ...state.formData[blocksFieldname][tileid],\n                mosaic_box_sizing,\n              },\n            },\n          },\n        };\n      },\n      () => {\n        // console.log('after resize', this.state);\n      },\n    );\n  }\n\n  onDragStop(layout, old, neu, x, e, node) {\n    // console.log('on drag stop'); // , layout, oldDragItem, l, x, e, node);\n    this.setState({\n      dirtyLayout: true,\n    });\n  }\n\n  // onResize(layout, old, neu, x, e, node) {\n  // console.log(\n  //   'on resize layout, oldDragItem, l, x, e, node',\n  //   layout,\n  //   oO, // oldDragItem, the element that was dragged\n  //   nO, // new dragged item, the element that became new\n  //   x,\n  //   e,\n  //   node,\n  // );\n  // let startH = neu.y;\n  // let endH = neu.y + neu.h;\n  // console.log('resize', layout, old, neu);\n  // TODO: find all elements that are on the same \"row\"\n  // change width of elements only if they are dW units \"left behind\"\n  // console.log('on resize');\n  // }\n\n  // onResizeStart(layout, oldDragItem, l, x, e, node) {\n  //   console.log('on resize start'); //, layout, oldDragItem, l, x, e, node);\n  //   // TODO: identify affected blocks, keep them in state, update their size\n  // }\n\n  // onDrag(layout, oldDragItem, l, x, e, node) {\n  //   // console.log(\n  //   //   'on drag layout, oldDragItem, l, x, e, node',\n  //   //   layout,\n  //   //   oldDragItem,\n  //   //   l,\n  //   //   x,\n  //   //   // e,\n  //   //   // node,\n  //   // );\n  // }\n\n  // onDragStart(layout, oldDragItem, l, x, e, node) {\n  //   // console.log('on drag start'); //, layout, oldDragItem, l, x, e, node);\n  // }\n\n  // onEditBlock(id, value, size) {\n  //   // Handles editing of tile by the tile editor\n  //   const blocksFieldname = getBlocksFieldname(this.state.formData);\n  //   this.setState({\n  //     formData: {\n  //       ...this.state.formData,\n  //       [blocksFieldname]: {\n  //         ...this.state.formData[blocksFieldname],\n  //         [id]: value || null,\n  //       },\n  //     },\n  //   });\n  // }\n}\n\nexport default injectIntl(Form, { forwardRef: true });\n","import { Icon as VoltoIcon } from '@plone/volto/components';\nimport React, { Component } from 'react';\nimport { Button, Dropdown, Grid, Radio } from 'semantic-ui-react';\nimport checkIcon from '@plone/volto/icons/check.svg';\n\nclass LayoutToolbar extends Component {\n  static defaultProps = {\n    // screens,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      currentScreenSize: 'lg',\n    };\n\n    this.getAvailableScreens = this.getAvailableScreens.bind(this);\n    this.sendAddBlock = this.sendAddBlock.bind(this);\n    this.sendChangeScreenSize = this.sendChangeScreenSize.bind(this);\n    this.sendDeleteLayout = this.sendDeleteLayout.bind(this);\n    this.sendPreviewResponsive = this.sendPreviewResponsive.bind(this);\n    this.sendPreviewBlocks = this.sendPreviewBlocks.bind(this);\n    this.sendSaveLayout = this.sendSaveLayout.bind(this);\n  }\n\n  sendChangeScreenSize(event, data) {\n    this.setState({ currentScreenSize: data.value }, () =>\n      this.props.dispatchToParent('CHANGE_SCREEN_SIZE', data.value),\n    );\n  }\n\n  sendPreviewResponsive(event, data) {\n    this.props.dispatchToParent('PREVIEW_RESPONSIVE', data.checked);\n  }\n\n  sendDeleteLayout() {\n    this.props.dispatchToParent('DELETE_LAYOUT', this.state.currentScreenSize);\n  }\n\n  sendSaveLayout() {\n    this.props.dispatchToParent('CREATE_LAYOUT', this.state.currentScreenSize);\n  }\n\n  sendPreviewBlocks(event, data) {\n    this.props.dispatchToParent('PREVIEW_TILES', data.checked);\n  }\n\n  sendAddBlock() {\n    this.props.dispatchToParent('CREATE_TILE', null);\n  }\n\n  getAvailableScreens() {\n    const layouts = this.props.layouts || {};\n    const screens = this.props.availableScreens.map(el => {\n      const res = Object.assign({}, el);\n      const has = Object.keys(layouts).indexOf(el.value) > -1;\n      // TODO: use appropriate icons, load fontawesome, something\n      if (has) res.icon = <VoltoIcon name={checkIcon} size=\"10\" />;\n      return res;\n    });\n    return screens;\n  }\n\n  render() {\n    const layouts = this.props.layouts || {};\n    const currentScreenSize = this.state.currentScreenSize;\n\n    const has = Object.keys(layouts).indexOf(currentScreenSize) > -1;\n\n    let showSaveButton;\n    let showDeleteButton;\n\n    if (currentScreenSize === 'lg') {\n      showSaveButton = false;\n      showDeleteButton = false;\n    } else {\n      showSaveButton = has ? false : true;\n      showDeleteButton = has ? true : false;\n    }\n\n    return (\n      <Grid columns={3}>\n        <Grid.Row>\n          <Grid.Column>\n            <div>\n              <Radio\n                toggle\n                checked={this.props.preview}\n                onChange={this.sendPreviewBlocks}\n              />\n              <small>Preview tiles</small>\n            </div>\n          </Grid.Column>\n\n          <Grid.Column>\n            <span>Select screen size</span>\n            <Dropdown\n              inline\n              onChange={this.sendChangeScreenSize}\n              options={this.getAvailableScreens()}\n              selection\n              value={this.state.currentScreenSize}\n            />\n          </Grid.Column>\n          <Grid.Column>\n            {showSaveButton ? (\n              <Button onClick={this.sendSaveLayout}>\n                Create responsive layout\n              </Button>\n            ) : (\n              ''\n            )}\n            {showDeleteButton ? (\n              <Button onClick={this.sendDeleteLayout}>\n                Delete responsive layout\n              </Button>\n            ) : (\n              ''\n            )}\n            {this.state.currentScreenSize === 'lg' ? (\n              <Button onClick={this.sendAddBlock}>Add new tile</Button>\n            ) : (\n              ''\n            )}\n          </Grid.Column>\n        </Grid.Row>\n      </Grid>\n    );\n  }\n}\n\nexport default LayoutToolbar;\n","import ReactDOM from 'react-dom';\nimport { breakpoints, rowHeight } from '../../config';\nimport React, { Component } from 'react';\nimport { Responsive } from 'react-grid-layout';\n// import WidthProvider from './WidthProvider';\nimport { blocks } from '~/config'; // settings,\nimport { SizeMe } from 'react-sizeme';\nimport _ from 'lodash';\n\nimport {\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n  // hasBlocksData,\n} from '@plone/volto/helpers';\n\nconst ReactGridLayout = Responsive;\n\nexport class BlockViewWrapper extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      updated: false,\n      ref: props.useref || React.createRef(),\n    };\n\n    this.getHeight = this.getHeight.bind(this);\n  }\n\n  render() {\n    const formData = this.props.formData;\n    const tileid = this.props.tileid;\n\n    const tilesFieldname = getBlocksFieldname(formData);\n    const blockData = formData[tilesFieldname][tileid];\n    if (!blockData) {\n      console.log('no tile data for tileid', tileid, formData[tilesFieldname]);\n      return '';\n    }\n    const tiletype = blockData['@type'].toLowerCase();\n\n    if (!blocks.tilesConfig[tiletype]) {\n      console.log('Block configuration not found', tiletype);\n      return '';\n    }\n\n    let Block = null;\n    Block = blocks.tilesConfig[tiletype].view;\n\n    let style = blockData.mosaic_box_style || 'default-tile';\n    let klass = 'tile-wrapper ' + style;\n\n    return Block !== null ? (\n      <div className=\"tile-container\" ref={this.state.ref}>\n        <div className={klass}>\n          {blockData.tile_title && blockData.show_tile_title && (\n            <h5 className=\"title-title\">{blockData.tile_title}</h5>\n          )}\n          <Block key={tileid} properties={formData} data={blockData} />\n        </div>\n      </div>\n    ) : (\n      <div> {JSON.stringify(tiletype)} </div>\n    );\n  }\n\n  getHeight() {\n    const node = ReactDOM.findDOMNode(this.state.ref.current);\n    let child = node && node.querySelector('.tile-wrapper > *');\n    // console.log('get height', node);\n    let height = (child && child.scrollHeight) || (node && node.scrollHeight);\n    // TODO: this is a hack. Need to make sure that this is correct;\n    // The problem is that tile-wrapper and its parrent tile-container are all\n    // 100% height. There is a conflict between need for static layout but also\n    // update dynamically, so we need to be a lot smarter and there will be\n    // a lot of edge cases that we can't avoid.\n    return height && height + 20; // also add paddings from tile-wrapper\n  }\n\n  componentDidMount() {\n    if (!this.props.showUpdate) return; // might not need this on View\n\n    this.setState({ updated: false }, () => {\n      const height = this.getHeight();\n      // console.log('componentDidMount', this.props.tileid, height);\n      this.props.showUpdate(this.props.tileid, height);\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (!this.props.showUpdate) return; // don't need this on View\n\n    // need this to avoid infinite recursion\n    if (\n      prevProps.containerWidth === this.props.containerWidth &&\n      this.state.updated\n    )\n      return;\n\n    this.setState({ updated: true }, () => {\n      const height = this.getHeight();\n      // console.log('componentDidUpdate default code', this.props.tileid, height);\n      this.props.showUpdate(this.props.tileid, height);\n    });\n  }\n}\n\nclass View extends Component {\n  static defaultProps = {\n    cols: 12,\n    margin: [0, 0],\n    onLayoutChange: function() {},\n  };\n\n  constructor(props) {\n    super(props);\n\n    const content = props.content;\n    const tilesLayoutFieldname = getBlocksLayoutFieldname(content);\n    const layout = content[tilesLayoutFieldname];\n    console.log('received layout', layout);\n\n    if (!__SERVER__) {\n      this.state = {\n        mosaic_layout: (layout && layout.mosaic_layout) || {},\n        items: (layout && layout.items) || {},\n        activeMosaicLayout: 'lg',\n        containerWidth: null,\n      };\n    } else {\n      this.state = {};\n    }\n\n    this.onBlockShowUpdate = this.onBlockShowUpdate.bind(this);\n    this.onBreakpointChange = this.onBreakpointChange.bind(this);\n    this.onWidthChange = this.onWidthChange.bind(this);\n  }\n\n  onBlockShowUpdate(tileid, height) {\n    const size = this.state.activeMosaicLayout;\n\n    const content = this.props.content;\n    const tilesLayoutFieldname = getBlocksLayoutFieldname(content);\n    const fullLayout = content[tilesLayoutFieldname];\n\n    let layout =\n      fullLayout.mosaic_layout &&\n      (fullLayout.mosaic_layout[size] || fullLayout.mosaic_layout['lg']);\n    if (!layout) return;\n    let tile = layout.find(t => t.i === tileid);\n    // let oldH = tile.h;\n    let h = Math.ceil(height / rowHeight);\n\n    this.setState((state, props) => {\n      let newState = {\n        ...state,\n        mosaic_layout: {\n          ...fullLayout.mosaic_layout,\n          [size]: [{ ...tile, h }, ..._.without(layout, tile)],\n        },\n      };\n      // console.log('new state', oldH, h, newState);\n\n      return newState;\n    });\n  }\n\n  renderBlocks() {\n    // console.log('render blocks');\n    return (\n      this.state.mosaic_layout['lg'] &&\n      this.state.mosaic_layout['lg'].map((item, i) => {\n        return (\n          <div key={item.i}>\n            <BlockViewWrapper\n              tileid={item.i}\n              formData={this.props.content}\n              showUpdate={this.onBlockShowUpdate}\n              containerWidth={this.state.containerWidth}\n            />\n          </div>\n        );\n      })\n    );\n  }\n\n  onBreakpointChange(bk, cols) {\n    console.log('New breakpoint', bk, cols, this.state.containerWidth);\n    this.setState({\n      activeMosaicLayout: bk,\n    });\n  }\n\n  onWidthChange(containerWidth, margin, cols, containerPadding) {\n    // (containerWidth: number,\n    //   margin: [number, number],\n    //   cols: number,\n    //   containerPadding: [number, number])\n    // console.log(\n    //   'On width change',\n    //   containerWidth,\n    //   margin,\n    //   cols,\n    //   containerPadding,\n    // );\n    let width = Math.floor(containerWidth);\n    if (Math.abs(width - this.state.containerWidth) > 6) {\n      console.log('new width', width);\n      this.setState({\n        containerWidth: width,\n      });\n    }\n  }\n\n  render() {\n    console.log(this.state.mosaic_layout);\n    return this.state.mosaic_layout ? (\n      <div className=\"mosaic_view\">\n        <SizeMe>\n          {({ size }) => (\n            <ReactGridLayout\n              layouts={this.state.mosaic_layout}\n              breakpoints={breakpoints}\n              cols={{\n                lg: 12,\n                md: this.state.mosaic_layout.md ? 12 : 9, // is this a good default?\n                sm: this.state.mosaic_layout.sm ? 12 : 4,\n                xs: this.state.mosaic_layout.xs ? 12 : 2,\n                xxs: this.state.mosaic_layout.xxs ? 12 : 1,\n              }}\n              onBreakpointChange={this.onBreakpointChange}\n              onWidthChange={this.onWidthChange}\n              measureBeforeMount={true}\n              rowHeight={rowHeight}\n              margin={[0, 0]}\n              isDraggable={false}\n              isResizable={false}\n              isDroppable={false}\n              width={size.width || document.querySelector('main').offsetWidth}\n            >\n              {this.renderBlocks()}\n            </ReactGridLayout>\n          )}\n        </SizeMe>\n        {this.state.mosaic_layout.mosaic_css_override && (\n          <style\n            dangerouslySetInnerHTML={{\n              __html: this.state.mosaic_layout.mosaic_css_override,\n            }}\n          />\n        )}\n      </div>\n    ) : (\n      ''\n    );\n  }\n}\n\nexport default View;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AA7BA;AACA;AAmCA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AACA;;;;;AA6DA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAFA;AALA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA7FA;AA8FA;AACA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAOA;AACA;AATA;AAYA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AAJA;AAUA;AAXA;AAaA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAnDA;AAqDA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAJA;AAFA;AAaA;AAEA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AAFA;AAWA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AAFA;AAWA;AACA;AAEA;;;AAEA;AACA;AAGA;;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAWA;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAHA;AAJA;AAYA;AACA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AADA;AAOA;AACA;AAEA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AAFA;AAPA;AAcA;AACA;AAEA;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AAGA;AAIA;AALA;AAUA;AADA;AApBA;AA2BA;AACA;AAEA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AADA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AA1BA;AACA;AA2BA;AACA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AALA;AADA;AAUA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAjDA;AAmDA;;;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AACA;AAEA,+BAoGA;AAyBA;;;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AANA;AAFA;AAaA;AAGA;AAEA;;;AAEA;AACA;AACA;AACA;AADA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAt6BA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AA3BA;AACA;AAFA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AA5BA;AACA;AAw4BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7iCA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAcA;AACA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;;AA5HA;AACA;AADA;AACA;AACA;AA6HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAMA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AAFA;AAKA;AARA;AASA;AACA;AAXA;AAAA;AAAA;AAaA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AA/CA;AAAA;AAAA;AAkDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AA5DA;AAAA;AAAA;AA8DA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAtEA;AAAA;AAAA;AAwEA;AACA;AAAA;AAEA;AACA;AAAA;AAMA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAvFA;AACA;AADA;AAAA;AACA;AAyFA;;;;;AAOA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA,iBAOA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAsBA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AACA;AACA;AAOA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAQA;AAEA;;;AAEA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAAA;AAAA;AAAA;AAAA;AADA;AA2BA;AACA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAUA;;;;AApJA;AACA;AADA;AAEA;AACA;AACA;AAHA;AACA;AAqJA;;;;;;;;;;A","sourceRoot":""}